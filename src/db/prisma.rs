// Code generated by Prisma Client Rust. DO NOT EDIT

# ! [allow (warnings , unused)] static DATAMODEL_STR : & 'static str = "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\ngenerator client {\n  // Corresponds to the cargo alias created earlier\n  provider = \"target/release/prisma_cli\"\n  // The location to generate the client. Is relative to the position of the schema\n  output   = \"../src/db/prisma.rs\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id         BigInt   @id @default(autoincrement())\n  name       String\n  username   String\n  avatar_url String\n  plugins    Plugin[]\n}\n\nmodel Plugin {\n  name         String    @id\n  description  String\n  display_name String\n  author       String\n  publisher    User      @relation(fields: [publisherId], references: [id])\n  publisherId  BigInt\n  versions     Version[]\n}\n\nmodel Version {\n  version    String\n  plugin     Plugin  @relation(fields: [pluginName], references: [name])\n  pluginName String\n  yanked     Boolean\n  digest     String\n  preview    Boolean\n\n  @@unique([version, pluginName])\n}\n" ; static DATABASE_STR : & 'static str = "postgresql" ; pub async fn new_client () -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { let config = :: prisma_client_rust :: datamodel :: parse_configuration (DATAMODEL_STR) ? . subject ; let source = config . datasources . first () . expect ("Please supply a datasource in your schema.prisma file") ; let url = if let Some (url) = source . load_shadow_database_url () ? { url } else { source . load_url (| key | std :: env :: var (key) . ok ()) ? } ; let url = if url . starts_with ("file:") { let path = url . split (":") . nth (1) . unwrap () ; if std :: path :: Path :: new ("./schema.prisma") . exists () { url } else if std :: path :: Path :: new ("./prisma/schema.prisma") . exists () { format ! ("file:./prisma/{}" , path) } else { url } } else { url } ; new_client_with_url (& url) . await } pub async fn new_client_with_url (url : & str) -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { let config = :: prisma_client_rust :: datamodel :: parse_configuration (DATAMODEL_STR) ? . subject ; let source = config . datasources . first () . expect ("Please supply a datasource in your schema.prisma file") ; let (db_name , executor) = :: prisma_client_rust :: query_core :: executor :: load (& source , & [] , & url) . await ? ; let internal_model = :: prisma_client_rust :: prisma_models :: InternalDataModelBuilder :: new (DATAMODEL_STR) . build (db_name) ; let query_schema = std :: sync :: Arc :: new (prisma_client_rust :: query_core :: schema_builder :: build (internal_model , true , source . capabilities () , vec ! [] , source . referential_integrity () ,)) ; executor . primary_connector () . get_connection () . await ? ; Ok (PrismaClient :: _new (executor , query_schema ,)) } pub mod user { use super :: * ; use super :: _prisma :: * ; pub mod id { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : i64) -> T { Set (value) . into () } pub fn equals < T : From < UniqueWhereParam >> (value : i64) -> T { UniqueWhereParam :: IdEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Id (direction) } pub fn in_vec (value : Vec < i64 >) -> WhereParam { WhereParam :: IdInVec (value) } pub fn not_in_vec (value : Vec < i64 >) -> WhereParam { WhereParam :: IdNotInVec (value) } pub fn lt (value : i64) -> WhereParam { WhereParam :: IdLt (value) } pub fn lte (value : i64) -> WhereParam { WhereParam :: IdLte (value) } pub fn gt (value : i64) -> WhereParam { WhereParam :: IdGt (value) } pub fn gte (value : i64) -> WhereParam { WhereParam :: IdGte (value) } pub fn not (value : i64) -> WhereParam { WhereParam :: IdNot (value) } pub fn increment (value : i64) -> SetParam { SetParam :: IncrementId (value) } pub fn decrement (value : i64) -> SetParam { SetParam :: DecrementId (value) } pub fn multiply (value : i64) -> SetParam { SetParam :: MultiplyId (value) } pub fn divide (value : i64) -> SetParam { SetParam :: DivideId (value) } pub struct Set (pub i64) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetId (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("id") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("id") . build () } } } pub mod name { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: NameEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Name (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: NameInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: NameNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: NameLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: NameLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: NameGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: NameGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: NameContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: NameStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: NameEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: NameMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: NameNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetName (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("name") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("name") . build () } } } pub mod username { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: UsernameEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Username (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: UsernameInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: UsernameNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: UsernameLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: UsernameLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: UsernameGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: UsernameGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: UsernameContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: UsernameStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: UsernameEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: UsernameMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: UsernameNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetUsername (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Username (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("username") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Username (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("username") . build () } } } pub mod avatar_url { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: AvatarUrlEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: AvatarUrl (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: AvatarUrlInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: AvatarUrlNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: AvatarUrlLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: AvatarUrlLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: AvatarUrlGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: AvatarUrlGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: AvatarUrlContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: AvatarUrlStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: AvatarUrlEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: AvatarUrlMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: AvatarUrlNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetAvatarUrl (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: AvatarUrl (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("avatar_url") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: AvatarUrl (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("avatar_url") . build () } } } pub mod plugins { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn some (value : Vec < plugin :: WhereParam >) -> WhereParam { WhereParam :: PluginsSome (value) } pub fn every (value : Vec < plugin :: WhereParam >) -> WhereParam { WhereParam :: PluginsEvery (value) } pub fn none (value : Vec < plugin :: WhereParam >) -> WhereParam { WhereParam :: PluginsNone (value) } pub struct Fetch (pub plugin :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < plugin :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : plugin :: OrderByParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : plugin :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (fetch : Fetch) -> Self { WithParam :: Plugins (fetch . 0) } } pub fn fetch (params : Vec < plugin :: WhereParam >) -> Fetch { Fetch (plugin :: ManyArgs :: new (params)) } pub fn connect < T : From < Connect >> (params : Vec < plugin :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < plugin :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectPlugins (params) } pub fn set (params : Vec < plugin :: UniqueWhereParam >) -> SetParam { SetParam :: SetPlugins (params) } pub struct Connect (pub Vec < plugin :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (value : Connect) -> Self { Self :: ConnectPlugins (value . 0) } } pub enum Include { Select (plugin :: ManyArgs , Vec < plugin :: SelectParam >) , Include (plugin :: ManyArgs , Vec < plugin :: IncludeParam >) , Fetch (plugin :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Plugins (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("plugins") ; match self { Self :: Select (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; let mut nested_selections = plugin :: _outputs () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; selection . nested_selections (nested_selections) ; } , Self :: Fetch (args) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (plugin :: _outputs ()) ; } } selection . build () } pub fn select (args : plugin :: ManyArgs , nested_selections : Vec < plugin :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : plugin :: ManyArgs , nested_selections : Vec < plugin :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } pub enum Select { Select (plugin :: ManyArgs , Vec < plugin :: SelectParam >) , Include (plugin :: ManyArgs , Vec < plugin :: IncludeParam >) , Fetch (plugin :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Plugins (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("plugins") ; match self { Self :: Select (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Fetch (args) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (plugin :: _outputs ()) ; } } selection . build () } pub fn select (args : plugin :: ManyArgs , nested_selections : Vec < plugin :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : plugin :: ManyArgs , nested_selections : Vec < plugin :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } } pub fn _outputs () -> Vec < :: prisma_client_rust :: Selection > { ["id" , "name" , "username" , "avatar_url"] . into_iter () . map (| o | { let builder = :: prisma_client_rust :: Selection :: builder (o) ; builder . build () }) . collect () } pub fn create (name : String , username : String , avatar_url : String , _params : Vec < SetParam >) -> (String , String , String , Vec < SetParam >) { (name , username , avatar_url , _params) } # [macro_export] macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , username , avatar_url , plugins } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (username) , stringify ! (avatar_url)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "username" , "avatar_url" , "plugins"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i64 } ; (@ field_type ; name) => { String } ; (@ field_type ; username) => { String } ; (@ field_type ; avatar_url) => { String } ; (@ field_type ; plugins : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < plugins :: Data > } ; (@ field_type ; plugins) => { Vec < crate :: prisma :: plugin :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "User" , available fields are "id, name, username, avatar_url, plugins")) } ; (@ field_module ; plugins : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: plugin :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: name :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: username :: Select) } ; (@ selection_field_to_selection_param ; avatar_url) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: avatar_url :: Select) } ; (@ selection_field_to_selection_param ; plugins $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: plugins :: Select :: $ selection_mode ($ crate :: prisma :: plugin :: ManyArgs :: new ($ crate :: prisma :: plugin :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: plugin :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; plugins $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: plugins :: Select :: Fetch ($ crate :: prisma :: plugin :: ManyArgs :: new ($ crate :: prisma :: plugin :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; avatar_url) => { "avatar_url" } ; (@ field_serde_name ; plugins) => { "plugins" } ; } pub use _select_user as select ; pub enum SelectParam { Id (id :: Select) , Name (name :: Select) , Username (username :: Select) , AvatarUrl (avatar_url :: Select) , Plugins (plugins :: Select) } impl SelectParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . to_selection () , Self :: Name (data) => data . to_selection () , Self :: Username (data) => data . to_selection () , Self :: AvatarUrl (data) => data . to_selection () , Self :: Plugins (data) => data . to_selection () } } } # [macro_export] macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { plugins } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub id : i64 , pub name : String , pub username : String , pub avatar_url : String , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (username) , stringify ! (avatar_url)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , & self . username) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; avatar_url) , & self . avatar_url) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , username , avatar_url } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; avatar_url) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) => Ok (Field :: username) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; avatar_url) => Ok (Field :: avatar_url) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut username = None ; let mut avatar_url = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ; } username = Some (map . next_value () ?) ; } Field :: avatar_url => { if avatar_url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; avatar_url))) ; } avatar_url = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name))) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ? ; let avatar_url = avatar_url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; avatar_url))) ? ; Ok (Data { id , name , username , avatar_url , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "username" , "avatar_url" , "plugins"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; plugins : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < plugins :: Data > } ; (@ field_type ; plugins) => { Vec < crate :: prisma :: plugin :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "plugins")) } ; (@ field_module ; plugins : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: plugin :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; plugins $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: plugins :: Include :: $ selection_mode ($ crate :: prisma :: plugin :: ManyArgs :: new ($ crate :: prisma :: plugin :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: plugin :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; plugins $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: user :: IncludeParam > :: into ($ crate :: prisma :: user :: plugins :: Include :: Fetch ($ crate :: prisma :: plugin :: ManyArgs :: new ($ crate :: prisma :: plugin :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; avatar_url) => { "avatar_url" } ; (@ field_serde_name ; plugins) => { "plugins" } ; } pub use _include_user as include ; pub enum IncludeParam { Id (id :: Include) , Name (name :: Include) , Username (username :: Include) , AvatarUrl (avatar_url :: Include) , Plugins (plugins :: Include) } impl IncludeParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . to_selection () , Self :: Name (data) => data . to_selection () , Self :: Username (data) => data . to_selection () , Self :: AvatarUrl (data) => data . to_selection () , Self :: Plugins (data) => data . to_selection () } } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : i64 , # [serde (rename = "name")] pub name : String , # [serde (rename = "username")] pub username : String , # [serde (rename = "avatar_url")] pub avatar_url : String , # [serde (rename = "plugins")] pub plugins : Option < Vec < super :: plugin :: Data > > } impl Data { pub fn plugins (& self) -> Result < & Vec < super :: plugin :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . plugins . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (plugins))) } } # [derive (Clone)] pub enum WithParam { Plugins (super :: plugin :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Plugins (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (super :: plugin :: _outputs ()) ; let mut builder = :: prisma_client_rust :: Selection :: builder ("plugins") ; builder . nested_selections (nested_selections) . set_arguments (arguments) ; builder . build () } } } } # [derive (Clone)] pub enum SetParam { SetId (i64) , IncrementId (i64) , DecrementId (i64) , MultiplyId (i64) , DivideId (i64) , SetName (String) , SetUsername (String) , SetAvatarUrl (String) , ConnectPlugins (Vec < super :: plugin :: UniqueWhereParam >) , DisconnectPlugins (Vec < super :: plugin :: UniqueWhereParam >) , SetPlugins (Vec < super :: plugin :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value)) , SetParam :: IncrementId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DecrementId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: MultiplyId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DivideId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetUsername (value) => ("username" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetAvatarUrl (value) => ("avatar_url" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectPlugins (where_params) => ("plugins" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: plugin :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectPlugins (where_params) => ("plugins" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: plugin :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetPlugins (where_params) => ("plugins" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: plugin :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } } } # [derive (Clone)] pub enum OrderByParam { Id (:: prisma_client_rust :: Direction) , Name (:: prisma_client_rust :: Direction) , Username (:: prisma_client_rust :: Direction) , AvatarUrl (:: prisma_client_rust :: Direction) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { Self :: Id (direction) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Name (direction) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Username (direction) => ("username" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: AvatarUrl (direction) => ("avatar_url" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) } } } # [derive (Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , IdEquals (i64) , IdInVec (Vec < i64 >) , IdNotInVec (Vec < i64 >) , IdLt (i64) , IdLte (i64) , IdGt (i64) , IdGte (i64) , IdNot (i64) , NameEquals (String) , NameInVec (Vec < String >) , NameNotInVec (Vec < String >) , NameLt (String) , NameLte (String) , NameGt (String) , NameGte (String) , NameContains (String) , NameStartsWith (String) , NameEndsWith (String) , NameMode (QueryMode) , NameNot (String) , UsernameEquals (String) , UsernameInVec (Vec < String >) , UsernameNotInVec (Vec < String >) , UsernameLt (String) , UsernameLte (String) , UsernameGt (String) , UsernameGte (String) , UsernameContains (String) , UsernameStartsWith (String) , UsernameEndsWith (String) , UsernameMode (QueryMode) , UsernameNot (String) , AvatarUrlEquals (String) , AvatarUrlInVec (Vec < String >) , AvatarUrlNotInVec (Vec < String >) , AvatarUrlLt (String) , AvatarUrlLte (String) , AvatarUrlGt (String) , AvatarUrlGte (String) , AvatarUrlContains (String) , AvatarUrlStartsWith (String) , AvatarUrlEndsWith (String) , AvatarUrlMode (QueryMode) , AvatarUrlNot (String) , PluginsSome (Vec < super :: plugin :: WhereParam >) , PluginsEvery (Vec < super :: plugin :: WhereParam >) , PluginsNone (Vec < super :: plugin :: WhereParam >) } impl Into < :: prisma_client_rust :: SerializedWhere > for WhereParam { fn into (self) -> :: prisma_client_rust :: SerializedWhere { match self { Self :: Not (value) => :: prisma_client_rust :: SerializedWhere :: new ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: Or (value) => :: prisma_client_rust :: SerializedWhere :: new ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => :: prisma_client_rust :: SerializedWhere :: new ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: IdEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: IdInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))])) , Self :: IdNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))])) , Self :: IdLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: IdLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: IdGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: IdGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: IdNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: NameEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: NameNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: NameLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: NameNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: UsernameNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: UsernameLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: UsernameMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: UsernameNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("username" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: AvatarUrlNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: AvatarUrlLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AvatarUrlMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: AvatarUrlNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("avatar_url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginsSome (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("plugins" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: PluginsEvery (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("plugins" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: PluginsNone (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("plugins" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) } } } # [derive (Clone)] pub enum UniqueWhereParam { IdEquals (i64) } impl From < UniqueWhereParam > for WhereParam { fn from (value : UniqueWhereParam) -> Self { match value { UniqueWhereParam :: IdEquals (value) => Self :: IdEquals (value) } } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < WithParam > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < WhereParam , WithParam , OrderByParam , UniqueWhereParam > ; pub type Count < 'a > = :: prisma_client_rust :: Count < 'a , WhereParam , OrderByParam , UniqueWhereParam > ; pub type Create < 'a > = :: prisma_client_rust :: Create < 'a , SetParam , WithParam , Data > ; pub type CreateMany < 'a > = :: prisma_client_rust :: CreateMany < 'a , SetParam > ; pub type FindUnique < 'a > = :: prisma_client_rust :: FindUnique < 'a , WhereParam , WithParam , SetParam , Data > ; pub type FindMany < 'a > = :: prisma_client_rust :: FindMany < 'a , WhereParam , WithParam , OrderByParam , UniqueWhereParam , SetParam , Data > ; pub type FindFirst < 'a > = :: prisma_client_rust :: FindFirst < 'a , WhereParam , WithParam , OrderByParam , UniqueWhereParam , Data > ; pub type Update < 'a > = :: prisma_client_rust :: Update < 'a , WhereParam , WithParam , SetParam , Data > ; pub type UpdateMany < 'a > = :: prisma_client_rust :: UpdateMany < 'a , WhereParam , SetParam > ; pub type Upsert < 'a > = :: prisma_client_rust :: Upsert < 'a , WhereParam , SetParam , WithParam , Data > ; pub type Delete < 'a > = :: prisma_client_rust :: Delete < 'a , WhereParam , WithParam , Data > ; pub type DeleteMany < 'a > = :: prisma_client_rust :: DeleteMany < 'a , WhereParam > ; pub struct Actions < 'a > { pub client : & 'a PrismaClient , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUnique < 'a > { FindUnique :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where . into ()) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirst < 'a > { FindFirst :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindMany < 'a > { FindMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where) } pub fn create (self , name : String , username : String , avatar_url : String , mut _params : Vec < SetParam >) -> Create < 'a > { _params . push (name :: set (name)) ; _params . push (username :: set (username)) ; _params . push (avatar_url :: set (avatar_url)) ; Create :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _params) } pub fn create_many (self , data : Vec < (String , String , String , Vec < SetParam >) >) -> CreateMany < 'a > { let data = data . into_iter () . map (| (name , username , avatar_url , mut _params) | { _params . push (name :: set (name)) ; _params . push (username :: set (username)) ; _params . push (avatar_url :: set (avatar_url)) ; _params }) . collect () ; CreateMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> Update < 'a > { Update :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where . into () , _params , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateMany < 'a > { UpdateMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , (name , username , avatar_url , mut _params) : (String , String , String , Vec < SetParam >) , _update : Vec < SetParam >) -> Upsert < 'a > { _params . push (name :: set (name)) ; _params . push (username :: set (username)) ; _params . push (avatar_url :: set (avatar_url)) ; Upsert :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where . into () , _params , _update) } pub fn delete (self , _where : UniqueWhereParam) -> Delete < 'a > { Delete :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where . into () , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteMany < 'a > { DeleteMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , _where . into ()) } pub fn count (self , _where : Vec < WhereParam >) -> Count < 'a > { Count :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("User" , _outputs ()) , vec ! []) } } } pub mod plugin { use super :: * ; use super :: _prisma :: * ; pub mod name { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals < T : From < UniqueWhereParam >> (value : String) -> T { UniqueWhereParam :: NameEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Name (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: NameInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: NameNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: NameLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: NameLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: NameGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: NameGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: NameContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: NameStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: NameEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: NameMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: NameNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetName (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("name") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("name") . build () } } } pub mod description { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: DescriptionEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Description (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: DescriptionInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: DescriptionNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: DescriptionLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: DescriptionLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: DescriptionGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: DescriptionGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: DescriptionContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: DescriptionStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: DescriptionEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: DescriptionMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: DescriptionNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetDescription (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Description (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("description") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Description (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("description") . build () } } } pub mod display_name { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: DisplayNameEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: DisplayName (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: DisplayNameInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: DisplayNameNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: DisplayNameLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: DisplayNameLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: DisplayNameGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: DisplayNameGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: DisplayNameContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: DisplayNameStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: DisplayNameEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: DisplayNameMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: DisplayNameNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetDisplayName (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: DisplayName (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("display_name") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: DisplayName (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("display_name") . build () } } } pub mod author { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: AuthorEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Author (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: AuthorInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: AuthorNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: AuthorLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: AuthorLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: AuthorGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: AuthorGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: AuthorContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: AuthorStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: AuthorEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: AuthorMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: AuthorNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetAuthor (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Author (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("author") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Author (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("author") . build () } } } pub mod publisher { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn is (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: PublisherIs (value) } pub fn is_not (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: PublisherIsNot (value) } pub struct Fetch (pub user :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < user :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (fetch : Fetch) -> Self { WithParam :: Publisher (fetch . 0) } } pub fn fetch () -> Fetch { Fetch (user :: UniqueArgs :: new ()) } pub fn connect < T : From < Connect >> (value : user :: UniqueWhereParam) -> T { Connect (value) . into () } pub struct Connect (user :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (value : Connect) -> Self { Self :: ConnectPublisher (value . 0) } } pub enum Include { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Publisher (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("publisher") ; match self { Self :: Select (selections) => { selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (selections) => { let mut nested_selections = user :: _outputs () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; selection . nested_selections (nested_selections) ; } , Self :: Fetch => { selection . nested_selections (user :: _outputs ()) ; } } selection . build () } pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } pub enum Select { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Publisher (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("publisher") ; match self { Self :: Select (selections) => { selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (selections) => { selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Fetch => { selection . nested_selections (user :: _outputs ()) ; } } selection . build () } pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } } pub mod publisher_id { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : i64) -> T { Set (value) . into () } pub fn equals (value : i64) -> WhereParam { WhereParam :: PublisherIdEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: PublisherId (direction) } pub fn in_vec (value : Vec < i64 >) -> WhereParam { WhereParam :: PublisherIdInVec (value) } pub fn not_in_vec (value : Vec < i64 >) -> WhereParam { WhereParam :: PublisherIdNotInVec (value) } pub fn lt (value : i64) -> WhereParam { WhereParam :: PublisherIdLt (value) } pub fn lte (value : i64) -> WhereParam { WhereParam :: PublisherIdLte (value) } pub fn gt (value : i64) -> WhereParam { WhereParam :: PublisherIdGt (value) } pub fn gte (value : i64) -> WhereParam { WhereParam :: PublisherIdGte (value) } pub fn not (value : i64) -> WhereParam { WhereParam :: PublisherIdNot (value) } pub fn increment (value : i64) -> SetParam { SetParam :: IncrementPublisherId (value) } pub fn decrement (value : i64) -> SetParam { SetParam :: DecrementPublisherId (value) } pub fn multiply (value : i64) -> SetParam { SetParam :: MultiplyPublisherId (value) } pub fn divide (value : i64) -> SetParam { SetParam :: DividePublisherId (value) } pub struct Set (pub i64) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetPublisherId (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: PublisherId (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("publisherId") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: PublisherId (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("publisherId") . build () } } } pub mod versions { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn some (value : Vec < version :: WhereParam >) -> WhereParam { WhereParam :: VersionsSome (value) } pub fn every (value : Vec < version :: WhereParam >) -> WhereParam { WhereParam :: VersionsEvery (value) } pub fn none (value : Vec < version :: WhereParam >) -> WhereParam { WhereParam :: VersionsNone (value) } pub struct Fetch (pub version :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < version :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : version :: OrderByParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : version :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (fetch : Fetch) -> Self { WithParam :: Versions (fetch . 0) } } pub fn fetch (params : Vec < version :: WhereParam >) -> Fetch { Fetch (version :: ManyArgs :: new (params)) } pub fn connect < T : From < Connect >> (params : Vec < version :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < version :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectVersions (params) } pub fn set (params : Vec < version :: UniqueWhereParam >) -> SetParam { SetParam :: SetVersions (params) } pub struct Connect (pub Vec < version :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (value : Connect) -> Self { Self :: ConnectVersions (value . 0) } } pub enum Include { Select (version :: ManyArgs , Vec < version :: SelectParam >) , Include (version :: ManyArgs , Vec < version :: IncludeParam >) , Fetch (version :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Versions (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("versions") ; match self { Self :: Select (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; let mut nested_selections = version :: _outputs () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; selection . nested_selections (nested_selections) ; } , Self :: Fetch (args) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (version :: _outputs ()) ; } } selection . build () } pub fn select (args : version :: ManyArgs , nested_selections : Vec < version :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : version :: ManyArgs , nested_selections : Vec < version :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } pub enum Select { Select (version :: ManyArgs , Vec < version :: SelectParam >) , Include (version :: ManyArgs , Vec < version :: IncludeParam >) , Fetch (version :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Versions (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("versions") ; match self { Self :: Select (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (args , selections) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Fetch (args) => { selection . set_arguments (args . to_graphql () . 0) ; selection . nested_selections (version :: _outputs ()) ; } } selection . build () } pub fn select (args : version :: ManyArgs , nested_selections : Vec < version :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : version :: ManyArgs , nested_selections : Vec < version :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } } pub fn _outputs () -> Vec < :: prisma_client_rust :: Selection > { ["name" , "description" , "display_name" , "author" , "publisherId"] . into_iter () . map (| o | { let builder = :: prisma_client_rust :: Selection :: builder (o) ; builder . build () }) . collect () } pub fn create (name : String , description : String , display_name : String , author : String , publisher_id : i64 , _params : Vec < SetParam >) -> (String , String , String , String , i64 , Vec < SetParam >) { (name , description , display_name , author , publisher_id , _params) } # [macro_export] macro_rules ! _select_plugin { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: plugin :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: plugin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: plugin :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: plugin :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: plugin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: plugin :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { name , description , display_name , author , publisher , publisher_id , versions } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: plugin :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (name) , stringify ! (description) , stringify ! (display_name) , stringify ! (author) , stringify ! (publisher_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: plugin :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: plugin :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: plugin :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["name" , "description" , "display_name" , "author" , "publisher" , "publisherId" , "versions"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: plugin :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; name) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; display_name) => { String } ; (@ field_type ; author) => { String } ; (@ field_type ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { publisher :: Data } ; (@ field_type ; publisher) => { crate :: prisma :: user :: Data } ; (@ field_type ; publisher_id) => { i64 } ; (@ field_type ; versions : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < versions :: Data > } ; (@ field_type ; versions) => { Vec < crate :: prisma :: version :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Plugin" , available fields are "name, description, display_name, author, publisher, publisher_id, versions")) } ; (@ field_module ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; versions : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: version :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: description :: Select) } ; (@ selection_field_to_selection_param ; display_name) => { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: display_name :: Select) } ; (@ selection_field_to_selection_param ; author) => { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: author :: Select) } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: publisher :: Select :: $ selection_mode ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: publisher :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; publisher_id) => { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: publisher_id :: Select) } ; (@ selection_field_to_selection_param ; versions $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: versions :: Select :: $ selection_mode ($ crate :: prisma :: version :: ManyArgs :: new ($ crate :: prisma :: version :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: version :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; versions $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: plugin :: SelectParam > :: into ($ crate :: prisma :: plugin :: versions :: Select :: Fetch ($ crate :: prisma :: version :: ManyArgs :: new ($ crate :: prisma :: version :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: plugin :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; display_name) => { "display_name" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; publisher) => { "publisher" } ; (@ field_serde_name ; publisher_id) => { "publisherId" } ; (@ field_serde_name ; versions) => { "versions" } ; } pub use _select_plugin as select ; pub enum SelectParam { Name (name :: Select) , Description (description :: Select) , DisplayName (display_name :: Select) , Author (author :: Select) , Publisher (publisher :: Select) , PublisherId (publisher_id :: Select) , Versions (versions :: Select) } impl SelectParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Name (data) => data . to_selection () , Self :: Description (data) => data . to_selection () , Self :: DisplayName (data) => data . to_selection () , Self :: Author (data) => data . to_selection () , Self :: Publisher (data) => data . to_selection () , Self :: PublisherId (data) => data . to_selection () , Self :: Versions (data) => data . to_selection () } } } # [macro_export] macro_rules ! _include_plugin { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: plugin :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: plugin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: plugin :: _outputs () ; selections . extend ($ crate :: prisma :: plugin :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: plugin :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: plugin :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: plugin :: _outputs () ; selections . extend ($ crate :: prisma :: plugin :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { publisher , versions } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub name : String , pub description : String , pub display_name : String , pub author : String , pub publisher_id : i64 , $ (pub $ field : $ crate :: prisma :: plugin :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (name) , stringify ! (description) , stringify ! (display_name) , stringify ! (author) , stringify ! (publisher_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; description) , & self . description) ? ; state . serialize_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; display_name) , & self . display_name) ? ; state . serialize_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; author) , & self . author) ? ; state . serialize_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; publisher_id) , & self . publisher_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , name , description , display_name , author , publisher_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; description) , ", " , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; display_name) , ", " , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; author) , ", " , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; publisher_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; description) => Ok (Field :: description) , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; display_name) => Ok (Field :: display_name) , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; author) => Ok (Field :: author) , $ crate :: prisma :: plugin :: include ! (@ field_serde_name ; publisher_id) => Ok (Field :: publisher_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut name = None ; let mut description = None ; let mut display_name = None ; let mut author = None ; let mut publisher_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; description))) ; } description = Some (map . next_value () ?) ; } Field :: display_name => { if display_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; display_name))) ; } display_name = Some (map . next_value () ?) ; } Field :: author => { if author . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; author))) ; } author = Some (map . next_value () ?) ; } Field :: publisher_id => { if publisher_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; publisher_id))) ; } publisher_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; $ field))) ? ;) * let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; name))) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; description))) ? ; let display_name = display_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; display_name))) ? ; let author = author . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; author))) ? ; let publisher_id = publisher_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: plugin :: include ! (@ field_serde_name ; publisher_id))) ? ; Ok (Data { name , description , display_name , author , publisher_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["name" , "description" , "display_name" , "author" , "publisher" , "publisherId" , "versions"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: plugin :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { publisher :: Data } ; (@ field_type ; publisher) => { crate :: prisma :: user :: Data } ; (@ field_type ; versions : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < versions :: Data > } ; (@ field_type ; versions) => { Vec < crate :: prisma :: version :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Plugin" , available relations are "publisher, versions")) } ; (@ field_module ; publisher : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; versions : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: version :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: plugin :: IncludeParam > :: into ($ crate :: prisma :: plugin :: publisher :: Include :: $ selection_mode ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; publisher $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: plugin :: IncludeParam > :: into ($ crate :: prisma :: plugin :: publisher :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; versions $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: plugin :: IncludeParam > :: into ($ crate :: prisma :: plugin :: versions :: Include :: $ selection_mode ($ crate :: prisma :: version :: ManyArgs :: new ($ crate :: prisma :: version :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: version :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; versions $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: plugin :: IncludeParam > :: into ($ crate :: prisma :: plugin :: versions :: Include :: Fetch ($ crate :: prisma :: version :: ManyArgs :: new ($ crate :: prisma :: version :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: plugin :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; display_name) => { "display_name" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; publisher) => { "publisher" } ; (@ field_serde_name ; publisher_id) => { "publisherId" } ; (@ field_serde_name ; versions) => { "versions" } ; } pub use _include_plugin as include ; pub enum IncludeParam { Name (name :: Include) , Description (description :: Include) , DisplayName (display_name :: Include) , Author (author :: Include) , Publisher (publisher :: Include) , PublisherId (publisher_id :: Include) , Versions (versions :: Include) } impl IncludeParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Name (data) => data . to_selection () , Self :: Description (data) => data . to_selection () , Self :: DisplayName (data) => data . to_selection () , Self :: Author (data) => data . to_selection () , Self :: Publisher (data) => data . to_selection () , Self :: PublisherId (data) => data . to_selection () , Self :: Versions (data) => data . to_selection () } } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "name")] pub name : String , # [serde (rename = "description")] pub description : String , # [serde (rename = "display_name")] pub display_name : String , # [serde (rename = "author")] pub author : String , # [serde (rename = "publisher")] pub publisher : Option < Box < super :: user :: Data > > , # [serde (rename = "publisherId")] pub publisher_id : i64 , # [serde (rename = "versions")] pub versions : Option < Vec < super :: version :: Data > > } impl Data { pub fn publisher (& self) -> Result < & super :: user :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . publisher . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (publisher))) . map (| v | v . as_ref ()) } pub fn versions (& self) -> Result < & Vec < super :: version :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . versions . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (versions))) } } # [derive (Clone)] pub enum WithParam { Publisher (super :: user :: UniqueArgs) , Versions (super :: version :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Publisher (args) => { let mut selections = super :: user :: _outputs () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; let mut builder = :: prisma_client_rust :: Selection :: builder ("publisher") ; builder . nested_selections (selections) ; builder . build () } , Self :: Versions (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (super :: version :: _outputs ()) ; let mut builder = :: prisma_client_rust :: Selection :: builder ("versions") ; builder . nested_selections (nested_selections) . set_arguments (arguments) ; builder . build () } } } } # [derive (Clone)] pub enum SetParam { SetName (String) , SetDescription (String) , SetDisplayName (String) , SetAuthor (String) , ConnectPublisher (super :: user :: UniqueWhereParam) , SetPublisherId (i64) , IncrementPublisherId (i64) , DecrementPublisherId (i64) , MultiplyPublisherId (i64) , DividePublisherId (i64) , ConnectVersions (Vec < super :: version :: UniqueWhereParam >) , DisconnectVersions (Vec < super :: version :: UniqueWhereParam >) , SetVersions (Vec < super :: version :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetDescription (value) => ("description" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetDisplayName (value) => ("display_name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetAuthor (value) => ("author" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectPublisher (where_param) => ("publisher" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: user :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()))])) , SetParam :: SetPublisherId (value) => ("publisherId" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value)) , SetParam :: IncrementPublisherId (value) => ("publisherId" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DecrementPublisherId (value) => ("publisherId" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: MultiplyPublisherId (value) => ("publisherId" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DividePublisherId (value) => ("publisherId" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: ConnectVersions (where_params) => ("versions" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: version :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectVersions (where_params) => ("versions" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: version :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetVersions (where_params) => ("versions" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: version :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } } } # [derive (Clone)] pub enum OrderByParam { Name (:: prisma_client_rust :: Direction) , Description (:: prisma_client_rust :: Direction) , DisplayName (:: prisma_client_rust :: Direction) , Author (:: prisma_client_rust :: Direction) , PublisherId (:: prisma_client_rust :: Direction) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { Self :: Name (direction) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Description (direction) => ("description" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: DisplayName (direction) => ("display_name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Author (direction) => ("author" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: PublisherId (direction) => ("publisherId" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) } } } # [derive (Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , NameEquals (String) , NameInVec (Vec < String >) , NameNotInVec (Vec < String >) , NameLt (String) , NameLte (String) , NameGt (String) , NameGte (String) , NameContains (String) , NameStartsWith (String) , NameEndsWith (String) , NameMode (QueryMode) , NameNot (String) , DescriptionEquals (String) , DescriptionInVec (Vec < String >) , DescriptionNotInVec (Vec < String >) , DescriptionLt (String) , DescriptionLte (String) , DescriptionGt (String) , DescriptionGte (String) , DescriptionContains (String) , DescriptionStartsWith (String) , DescriptionEndsWith (String) , DescriptionMode (QueryMode) , DescriptionNot (String) , DisplayNameEquals (String) , DisplayNameInVec (Vec < String >) , DisplayNameNotInVec (Vec < String >) , DisplayNameLt (String) , DisplayNameLte (String) , DisplayNameGt (String) , DisplayNameGte (String) , DisplayNameContains (String) , DisplayNameStartsWith (String) , DisplayNameEndsWith (String) , DisplayNameMode (QueryMode) , DisplayNameNot (String) , AuthorEquals (String) , AuthorInVec (Vec < String >) , AuthorNotInVec (Vec < String >) , AuthorLt (String) , AuthorLte (String) , AuthorGt (String) , AuthorGte (String) , AuthorContains (String) , AuthorStartsWith (String) , AuthorEndsWith (String) , AuthorMode (QueryMode) , AuthorNot (String) , PublisherIs (Vec < super :: user :: WhereParam >) , PublisherIsNot (Vec < super :: user :: WhereParam >) , PublisherIdEquals (i64) , PublisherIdInVec (Vec < i64 >) , PublisherIdNotInVec (Vec < i64 >) , PublisherIdLt (i64) , PublisherIdLte (i64) , PublisherIdGt (i64) , PublisherIdGte (i64) , PublisherIdNot (i64) , VersionsSome (Vec < super :: version :: WhereParam >) , VersionsEvery (Vec < super :: version :: WhereParam >) , VersionsNone (Vec < super :: version :: WhereParam >) } impl Into < :: prisma_client_rust :: SerializedWhere > for WhereParam { fn into (self) -> :: prisma_client_rust :: SerializedWhere { match self { Self :: Not (value) => :: prisma_client_rust :: SerializedWhere :: new ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: Or (value) => :: prisma_client_rust :: SerializedWhere :: new ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => :: prisma_client_rust :: SerializedWhere :: new ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: NameEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: NameNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: NameLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: NameNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: DescriptionNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: DescriptionLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DescriptionMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: DescriptionNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("description" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: DisplayNameNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: DisplayNameLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DisplayNameMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: DisplayNameNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("display_name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: AuthorNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: AuthorLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: AuthorMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: AuthorNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("author" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PublisherIs (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("publisher" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: PublisherIsNot (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("publisher" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: PublisherIdEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: PublisherIdInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))])) , Self :: PublisherIdNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))])) , Self :: PublisherIdLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: PublisherIdLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: PublisherIdGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: PublisherIdGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: PublisherIdNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("publisherId" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: VersionsSome (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("versions" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: VersionsEvery (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("versions" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: VersionsNone (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("versions" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) } } } # [derive (Clone)] pub enum UniqueWhereParam { NameEquals (String) } impl From < UniqueWhereParam > for WhereParam { fn from (value : UniqueWhereParam) -> Self { match value { UniqueWhereParam :: NameEquals (value) => Self :: NameEquals (value) } } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < WithParam > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < WhereParam , WithParam , OrderByParam , UniqueWhereParam > ; pub type Count < 'a > = :: prisma_client_rust :: Count < 'a , WhereParam , OrderByParam , UniqueWhereParam > ; pub type Create < 'a > = :: prisma_client_rust :: Create < 'a , SetParam , WithParam , Data > ; pub type CreateMany < 'a > = :: prisma_client_rust :: CreateMany < 'a , SetParam > ; pub type FindUnique < 'a > = :: prisma_client_rust :: FindUnique < 'a , WhereParam , WithParam , SetParam , Data > ; pub type FindMany < 'a > = :: prisma_client_rust :: FindMany < 'a , WhereParam , WithParam , OrderByParam , UniqueWhereParam , SetParam , Data > ; pub type FindFirst < 'a > = :: prisma_client_rust :: FindFirst < 'a , WhereParam , WithParam , OrderByParam , UniqueWhereParam , Data > ; pub type Update < 'a > = :: prisma_client_rust :: Update < 'a , WhereParam , WithParam , SetParam , Data > ; pub type UpdateMany < 'a > = :: prisma_client_rust :: UpdateMany < 'a , WhereParam , SetParam > ; pub type Upsert < 'a > = :: prisma_client_rust :: Upsert < 'a , WhereParam , SetParam , WithParam , Data > ; pub type Delete < 'a > = :: prisma_client_rust :: Delete < 'a , WhereParam , WithParam , Data > ; pub type DeleteMany < 'a > = :: prisma_client_rust :: DeleteMany < 'a , WhereParam > ; pub struct Actions < 'a > { pub client : & 'a PrismaClient , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUnique < 'a > { FindUnique :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where . into ()) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirst < 'a > { FindFirst :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindMany < 'a > { FindMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where) } pub fn create (self , name : String , description : String , display_name : String , author : String , publisher : super :: user :: UniqueWhereParam , mut _params : Vec < SetParam >) -> Create < 'a > { _params . push (name :: set (name)) ; _params . push (description :: set (description)) ; _params . push (display_name :: set (display_name)) ; _params . push (author :: set (author)) ; _params . push (publisher :: connect (publisher)) ; Create :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _params) } pub fn create_many (self , data : Vec < (String , String , String , String , i64 , Vec < SetParam >) >) -> CreateMany < 'a > { let data = data . into_iter () . map (| (name , description , display_name , author , publisher_id , mut _params) | { _params . push (name :: set (name)) ; _params . push (description :: set (description)) ; _params . push (display_name :: set (display_name)) ; _params . push (author :: set (author)) ; _params . push (publisher_id :: set (publisher_id)) ; _params }) . collect () ; CreateMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> Update < 'a > { Update :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where . into () , _params , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateMany < 'a > { UpdateMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , (name , description , display_name , author , publisher , mut _params) : (String , String , String , String , super :: user :: UniqueWhereParam , Vec < SetParam >) , _update : Vec < SetParam >) -> Upsert < 'a > { _params . push (name :: set (name)) ; _params . push (description :: set (description)) ; _params . push (display_name :: set (display_name)) ; _params . push (author :: set (author)) ; _params . push (publisher :: connect (publisher)) ; Upsert :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where . into () , _params , _update) } pub fn delete (self , _where : UniqueWhereParam) -> Delete < 'a > { Delete :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where . into () , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteMany < 'a > { DeleteMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , _where . into ()) } pub fn count (self , _where : Vec < WhereParam >) -> Count < 'a > { Count :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Plugin" , _outputs ()) , vec ! []) } } } pub mod version { use super :: * ; use super :: _prisma :: * ; pub mod version { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: VersionEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Version (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: VersionInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: VersionNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: VersionLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: VersionLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: VersionGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: VersionGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: VersionContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: VersionStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: VersionEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: VersionMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: VersionNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetVersion (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Version (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("version") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Version (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("version") . build () } } } pub mod plugin { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn is (value : Vec < plugin :: WhereParam >) -> WhereParam { WhereParam :: PluginIs (value) } pub fn is_not (value : Vec < plugin :: WhereParam >) -> WhereParam { WhereParam :: PluginIsNot (value) } pub struct Fetch (pub plugin :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < plugin :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (fetch : Fetch) -> Self { WithParam :: Plugin (fetch . 0) } } pub fn fetch () -> Fetch { Fetch (plugin :: UniqueArgs :: new ()) } pub fn connect < T : From < Connect >> (value : plugin :: UniqueWhereParam) -> T { Connect (value) . into () } pub struct Connect (plugin :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (value : Connect) -> Self { Self :: ConnectPlugin (value . 0) } } pub enum Include { Select (Vec < plugin :: SelectParam >) , Include (Vec < plugin :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Plugin (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("plugin") ; match self { Self :: Select (selections) => { selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (selections) => { let mut nested_selections = plugin :: _outputs () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; selection . nested_selections (nested_selections) ; } , Self :: Fetch => { selection . nested_selections (plugin :: _outputs ()) ; } } selection . build () } pub fn select (nested_selections : Vec < plugin :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < plugin :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } pub enum Select { Select (Vec < plugin :: SelectParam >) , Include (Vec < plugin :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Plugin (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let mut selection = :: prisma_client_rust :: Selection :: builder ("plugin") ; match self { Self :: Select (selections) => { selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Include (selections) => { selection . nested_selections (selections . into_iter () . map (| s | s . to_selection ()) . collect ()) ; } , Self :: Fetch => { selection . nested_selections (plugin :: _outputs ()) ; } } selection . build () } pub fn select (nested_selections : Vec < plugin :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < plugin :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } } pub mod plugin_name { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: PluginNameEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: PluginName (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: PluginNameInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: PluginNameNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: PluginNameLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: PluginNameLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: PluginNameGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: PluginNameGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: PluginNameContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: PluginNameStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: PluginNameEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: PluginNameMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: PluginNameNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetPluginName (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: PluginName (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("pluginName") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: PluginName (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("pluginName") . build () } } } pub mod yanked { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : bool) -> T { Set (value) . into () } pub fn equals (value : bool) -> WhereParam { WhereParam :: YankedEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Yanked (direction) } pub struct Set (pub bool) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetYanked (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Yanked (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("yanked") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Yanked (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("yanked") . build () } } } pub mod digest { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn equals (value : String) -> WhereParam { WhereParam :: DigestEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Digest (direction) } pub fn in_vec (value : Vec < String >) -> WhereParam { WhereParam :: DigestInVec (value) } pub fn not_in_vec (value : Vec < String >) -> WhereParam { WhereParam :: DigestNotInVec (value) } pub fn lt (value : String) -> WhereParam { WhereParam :: DigestLt (value) } pub fn lte (value : String) -> WhereParam { WhereParam :: DigestLte (value) } pub fn gt (value : String) -> WhereParam { WhereParam :: DigestGt (value) } pub fn gte (value : String) -> WhereParam { WhereParam :: DigestGte (value) } pub fn contains (value : String) -> WhereParam { WhereParam :: DigestContains (value) } pub fn starts_with (value : String) -> WhereParam { WhereParam :: DigestStartsWith (value) } pub fn ends_with (value : String) -> WhereParam { WhereParam :: DigestEndsWith (value) } pub fn mode (value : QueryMode) -> WhereParam { WhereParam :: DigestMode (value) } pub fn not (value : String) -> WhereParam { WhereParam :: DigestNot (value) } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetDigest (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Digest (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("digest") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Digest (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("digest") . build () } } } pub mod preview { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam } ; use super :: _prisma :: * ; pub fn set < T : From < Set >> (value : bool) -> T { Set (value) . into () } pub fn equals (value : bool) -> WhereParam { WhereParam :: PreviewEquals (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Preview (direction) } pub struct Set (pub bool) ; impl From < Set > for SetParam { fn from (value : Set) -> Self { Self :: SetPreview (value . 0) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Preview (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("preview") . build () } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Preview (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: Selection :: builder ("preview") . build () } } } pub fn version_plugin_name < T : From < UniqueWhereParam >> (version : String , plugin_name : String) -> T { UniqueWhereParam :: VersionPluginNameEquals (version , plugin_name) . into () } pub fn _outputs () -> Vec < :: prisma_client_rust :: Selection > { ["version" , "pluginName" , "yanked" , "digest" , "preview"] . into_iter () . map (| o | { let builder = :: prisma_client_rust :: Selection :: builder (o) ; builder . build () }) . collect () } pub fn create (version : String , plugin_name : String , yanked : bool , digest : String , preview : bool , _params : Vec < SetParam >) -> (String , String , bool , String , bool , Vec < SetParam >) { (version , plugin_name , yanked , digest , preview , _params) } # [macro_export] macro_rules ! _select_version { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: version :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: version :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: version :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: version :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: version :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: version :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { version , plugin , plugin_name , yanked , digest , preview } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: version :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (version) , stringify ! (plugin_name) , stringify ! (yanked) , stringify ! (digest) , stringify ! (preview)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: version :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: version :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: version :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["version" , "plugin" , "pluginName" , "yanked" , "digest" , "preview"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: version :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; version) => { String } ; (@ field_type ; plugin : $ selection_mode : ident { $ ($ selections : tt) + }) => { plugin :: Data } ; (@ field_type ; plugin) => { crate :: prisma :: plugin :: Data } ; (@ field_type ; plugin_name) => { String } ; (@ field_type ; yanked) => { bool } ; (@ field_type ; digest) => { String } ; (@ field_type ; preview) => { bool } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Version" , available fields are "version, plugin, plugin_name, yanked, digest, preview")) } ; (@ field_module ; plugin : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: plugin :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; version) => { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: version :: Select) } ; (@ selection_field_to_selection_param ; plugin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: plugin :: Select :: $ selection_mode ($ crate :: prisma :: plugin :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; plugin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: plugin :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; plugin_name) => { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: plugin_name :: Select) } ; (@ selection_field_to_selection_param ; yanked) => { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: yanked :: Select) } ; (@ selection_field_to_selection_param ; digest) => { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: digest :: Select) } ; (@ selection_field_to_selection_param ; preview) => { Into :: < $ crate :: prisma :: version :: SelectParam > :: into ($ crate :: prisma :: version :: preview :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: version :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; plugin) => { "plugin" } ; (@ field_serde_name ; plugin_name) => { "pluginName" } ; (@ field_serde_name ; yanked) => { "yanked" } ; (@ field_serde_name ; digest) => { "digest" } ; (@ field_serde_name ; preview) => { "preview" } ; } pub use _select_version as select ; pub enum SelectParam { Version (version :: Select) , Plugin (plugin :: Select) , PluginName (plugin_name :: Select) , Yanked (yanked :: Select) , Digest (digest :: Select) , Preview (preview :: Select) } impl SelectParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Version (data) => data . to_selection () , Self :: Plugin (data) => data . to_selection () , Self :: PluginName (data) => data . to_selection () , Self :: Yanked (data) => data . to_selection () , Self :: Digest (data) => data . to_selection () , Self :: Preview (data) => data . to_selection () } } } # [macro_export] macro_rules ! _include_version { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: version :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: version :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: version :: _outputs () ; selections . extend ($ crate :: prisma :: version :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: version :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: version :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: version :: _outputs () ; selections . extend ($ crate :: prisma :: version :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { plugin } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub version : String , pub plugin_name : String , pub yanked : bool , pub digest : String , pub preview : bool , $ (pub $ field : $ crate :: prisma :: version :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (version) , stringify ! (plugin_name) , stringify ! (yanked) , stringify ! (digest) , stringify ! (preview)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; version) , & self . version) ? ; state . serialize_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; plugin_name) , & self . plugin_name) ? ; state . serialize_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; yanked) , & self . yanked) ? ; state . serialize_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; digest) , & self . digest) ? ; state . serialize_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; preview) , & self . preview) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , version , plugin_name , yanked , digest , preview } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: version :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: version :: include ! (@ field_serde_name ; version) , ", " , $ crate :: prisma :: version :: include ! (@ field_serde_name ; plugin_name) , ", " , $ crate :: prisma :: version :: include ! (@ field_serde_name ; yanked) , ", " , $ crate :: prisma :: version :: include ! (@ field_serde_name ; digest) , ", " , $ crate :: prisma :: version :: include ! (@ field_serde_name ; preview) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: version :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: version :: include ! (@ field_serde_name ; version) => Ok (Field :: version) , $ crate :: prisma :: version :: include ! (@ field_serde_name ; plugin_name) => Ok (Field :: plugin_name) , $ crate :: prisma :: version :: include ! (@ field_serde_name ; yanked) => Ok (Field :: yanked) , $ crate :: prisma :: version :: include ! (@ field_serde_name ; digest) => Ok (Field :: digest) , $ crate :: prisma :: version :: include ! (@ field_serde_name ; preview) => Ok (Field :: preview) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut version = None ; let mut plugin_name = None ; let mut yanked = None ; let mut digest = None ; let mut preview = None ; while let Some (key) = map . next_key () ? { match key { Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; version))) ; } version = Some (map . next_value () ?) ; } Field :: plugin_name => { if plugin_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; plugin_name))) ; } plugin_name = Some (map . next_value () ?) ; } Field :: yanked => { if yanked . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; yanked))) ; } yanked = Some (map . next_value () ?) ; } Field :: digest => { if digest . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; digest))) ; } digest = Some (map . next_value () ?) ; } Field :: preview => { if preview . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; preview))) ; } preview = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; $ field))) ? ;) * let version = version . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; version))) ? ; let plugin_name = plugin_name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; plugin_name))) ? ; let yanked = yanked . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; yanked))) ? ; let digest = digest . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; digest))) ? ; let preview = preview . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: version :: include ! (@ field_serde_name ; preview))) ? ; Ok (Data { version , plugin_name , yanked , digest , preview , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["version" , "plugin" , "pluginName" , "yanked" , "digest" , "preview"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: version :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; plugin : $ selection_mode : ident { $ ($ selections : tt) + }) => { plugin :: Data } ; (@ field_type ; plugin) => { crate :: prisma :: plugin :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Version" , available relations are "plugin")) } ; (@ field_module ; plugin : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: plugin :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; plugin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: version :: IncludeParam > :: into ($ crate :: prisma :: version :: plugin :: Include :: $ selection_mode ($ crate :: prisma :: plugin :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; plugin $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: version :: IncludeParam > :: into ($ crate :: prisma :: version :: plugin :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: version :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; plugin) => { "plugin" } ; (@ field_serde_name ; plugin_name) => { "pluginName" } ; (@ field_serde_name ; yanked) => { "yanked" } ; (@ field_serde_name ; digest) => { "digest" } ; (@ field_serde_name ; preview) => { "preview" } ; } pub use _include_version as include ; pub enum IncludeParam { Version (version :: Include) , Plugin (plugin :: Include) , PluginName (plugin_name :: Include) , Yanked (yanked :: Include) , Digest (digest :: Include) , Preview (preview :: Include) } impl IncludeParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Version (data) => data . to_selection () , Self :: Plugin (data) => data . to_selection () , Self :: PluginName (data) => data . to_selection () , Self :: Yanked (data) => data . to_selection () , Self :: Digest (data) => data . to_selection () , Self :: Preview (data) => data . to_selection () } } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "version")] pub version : String , # [serde (rename = "plugin")] pub plugin : Option < Box < super :: plugin :: Data > > , # [serde (rename = "pluginName")] pub plugin_name : String , # [serde (rename = "yanked")] pub yanked : bool , # [serde (rename = "digest")] pub digest : String , # [serde (rename = "preview")] pub preview : bool } impl Data { pub fn plugin (& self) -> Result < & super :: plugin :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . plugin . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (plugin))) . map (| v | v . as_ref ()) } } # [derive (Clone)] pub enum WithParam { Plugin (super :: plugin :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Plugin (args) => { let mut selections = super :: plugin :: _outputs () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; let mut builder = :: prisma_client_rust :: Selection :: builder ("plugin") ; builder . nested_selections (selections) ; builder . build () } } } } # [derive (Clone)] pub enum SetParam { SetVersion (String) , ConnectPlugin (super :: plugin :: UniqueWhereParam) , SetPluginName (String) , SetYanked (bool) , SetDigest (String) , SetPreview (bool) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { SetParam :: SetVersion (value) => ("version" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectPlugin (where_param) => ("plugin" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: plugin :: WhereParam > :: into) . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()))])) , SetParam :: SetPluginName (value) => ("pluginName" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetYanked (value) => ("yanked" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetDigest (value) => ("digest" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetPreview (value) => ("preview" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) } } } # [derive (Clone)] pub enum OrderByParam { Version (:: prisma_client_rust :: Direction) , PluginName (:: prisma_client_rust :: Direction) , Yanked (:: prisma_client_rust :: Direction) , Digest (:: prisma_client_rust :: Direction) , Preview (:: prisma_client_rust :: Direction) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { Self :: Version (direction) => ("version" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: PluginName (direction) => ("pluginName" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Yanked (direction) => ("yanked" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Digest (direction) => ("digest" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Preview (direction) => ("preview" . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) } } } # [derive (Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , VersionPluginNameEquals (String , String) , VersionEquals (String) , VersionInVec (Vec < String >) , VersionNotInVec (Vec < String >) , VersionLt (String) , VersionLte (String) , VersionGt (String) , VersionGte (String) , VersionContains (String) , VersionStartsWith (String) , VersionEndsWith (String) , VersionMode (QueryMode) , VersionNot (String) , PluginIs (Vec < super :: plugin :: WhereParam >) , PluginIsNot (Vec < super :: plugin :: WhereParam >) , PluginNameEquals (String) , PluginNameInVec (Vec < String >) , PluginNameNotInVec (Vec < String >) , PluginNameLt (String) , PluginNameLte (String) , PluginNameGt (String) , PluginNameGte (String) , PluginNameContains (String) , PluginNameStartsWith (String) , PluginNameEndsWith (String) , PluginNameMode (QueryMode) , PluginNameNot (String) , YankedEquals (bool) , DigestEquals (String) , DigestInVec (Vec < String >) , DigestNotInVec (Vec < String >) , DigestLt (String) , DigestLte (String) , DigestGt (String) , DigestGte (String) , DigestContains (String) , DigestStartsWith (String) , DigestEndsWith (String) , DigestMode (QueryMode) , DigestNot (String) , PreviewEquals (bool) } impl Into < :: prisma_client_rust :: SerializedWhere > for WhereParam { fn into (self) -> :: prisma_client_rust :: SerializedWhere { match self { Self :: Not (value) => :: prisma_client_rust :: SerializedWhere :: new ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: Or (value) => :: prisma_client_rust :: SerializedWhere :: new ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => :: prisma_client_rust :: SerializedWhere :: new ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: VersionPluginNameEquals (version , plugin_name) => :: prisma_client_rust :: SerializedWhere :: new ("version_pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("version" . to_string () , :: prisma_client_rust :: PrismaValue :: String (version)) , ("pluginName" . to_string () , :: prisma_client_rust :: PrismaValue :: String (plugin_name))])) , Self :: VersionEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: VersionNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: VersionLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: VersionMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: VersionNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("version" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginIs (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("plugin" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: PluginIsNot (where_params) => :: prisma_client_rust :: SerializedWhere :: new ("plugin" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (:: prisma_client_rust :: SerializedWhere :: transform_equals) . collect ()) ,)])) , Self :: PluginNameEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: PluginNameNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: PluginNameLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PluginNameMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: PluginNameNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("pluginName" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: YankedEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("yanked" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value))])) , Self :: DigestEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: DigestNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: DigestLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: DigestMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: DigestNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("digest" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PreviewEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("preview" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value))])) } } } # [derive (Clone)] pub enum UniqueWhereParam { VersionPluginNameEquals (String , String) } impl From < UniqueWhereParam > for WhereParam { fn from (value : UniqueWhereParam) -> Self { match value { UniqueWhereParam :: VersionPluginNameEquals (version , plugin_name) => Self :: VersionPluginNameEquals (version , plugin_name) } } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < WithParam > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < WhereParam , WithParam , OrderByParam , UniqueWhereParam > ; pub type Count < 'a > = :: prisma_client_rust :: Count < 'a , WhereParam , OrderByParam , UniqueWhereParam > ; pub type Create < 'a > = :: prisma_client_rust :: Create < 'a , SetParam , WithParam , Data > ; pub type CreateMany < 'a > = :: prisma_client_rust :: CreateMany < 'a , SetParam > ; pub type FindUnique < 'a > = :: prisma_client_rust :: FindUnique < 'a , WhereParam , WithParam , SetParam , Data > ; pub type FindMany < 'a > = :: prisma_client_rust :: FindMany < 'a , WhereParam , WithParam , OrderByParam , UniqueWhereParam , SetParam , Data > ; pub type FindFirst < 'a > = :: prisma_client_rust :: FindFirst < 'a , WhereParam , WithParam , OrderByParam , UniqueWhereParam , Data > ; pub type Update < 'a > = :: prisma_client_rust :: Update < 'a , WhereParam , WithParam , SetParam , Data > ; pub type UpdateMany < 'a > = :: prisma_client_rust :: UpdateMany < 'a , WhereParam , SetParam > ; pub type Upsert < 'a > = :: prisma_client_rust :: Upsert < 'a , WhereParam , SetParam , WithParam , Data > ; pub type Delete < 'a > = :: prisma_client_rust :: Delete < 'a , WhereParam , WithParam , Data > ; pub type DeleteMany < 'a > = :: prisma_client_rust :: DeleteMany < 'a , WhereParam > ; pub struct Actions < 'a > { pub client : & 'a PrismaClient , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUnique < 'a > { FindUnique :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where . into ()) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirst < 'a > { FindFirst :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindMany < 'a > { FindMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where) } pub fn create (self , version : String , plugin : super :: plugin :: UniqueWhereParam , yanked : bool , digest : String , preview : bool , mut _params : Vec < SetParam >) -> Create < 'a > { _params . push (version :: set (version)) ; _params . push (plugin :: connect (plugin)) ; _params . push (yanked :: set (yanked)) ; _params . push (digest :: set (digest)) ; _params . push (preview :: set (preview)) ; Create :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _params) } pub fn create_many (self , data : Vec < (String , String , bool , String , bool , Vec < SetParam >) >) -> CreateMany < 'a > { let data = data . into_iter () . map (| (version , plugin_name , yanked , digest , preview , mut _params) | { _params . push (version :: set (version)) ; _params . push (plugin_name :: set (plugin_name)) ; _params . push (yanked :: set (yanked)) ; _params . push (digest :: set (digest)) ; _params . push (preview :: set (preview)) ; _params }) . collect () ; CreateMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> Update < 'a > { Update :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where . into () , _params , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateMany < 'a > { UpdateMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , (version , plugin , yanked , digest , preview , mut _params) : (String , super :: plugin :: UniqueWhereParam , bool , String , bool , Vec < SetParam >) , _update : Vec < SetParam >) -> Upsert < 'a > { _params . push (version :: set (version)) ; _params . push (plugin :: connect (plugin)) ; _params . push (yanked :: set (yanked)) ; _params . push (digest :: set (digest)) ; _params . push (preview :: set (preview)) ; Upsert :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where . into () , _params , _update) } pub fn delete (self , _where : UniqueWhereParam) -> Delete < 'a > { Delete :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where . into () , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteMany < 'a > { DeleteMany :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , _where . into ()) } pub fn count (self , _where : Vec < WhereParam >) -> Count < 'a > { Count :: new (self . client . _new_query_context () , :: prisma_client_rust :: QueryInfo :: new ("Version" , _outputs ()) , vec ! []) } } } pub mod _prisma { pub struct PrismaClient { executor : :: prisma_client_rust :: Executor , query_schema : :: std :: sync :: Arc < :: prisma_client_rust :: schema :: QuerySchema > , } impl :: std :: fmt :: Debug for PrismaClient { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . debug_struct ("PrismaClient") . finish () } } impl PrismaClient { pub (super) fn _new_query_context (& self) -> :: prisma_client_rust :: queries :: QueryContext { :: prisma_client_rust :: queries :: QueryContext :: new (& self . executor , & self . query_schema) } pub (super) fn _new (executor : :: prisma_client_rust :: Executor , query_schema : std :: sync :: Arc < :: prisma_client_rust :: schema :: QuerySchema >) -> Self { Self { executor , query_schema , } } pub fn _query_raw < T : serde :: de :: DeserializeOwned > (& self , query : :: prisma_client_rust :: raw :: Raw) -> :: prisma_client_rust :: QueryRaw < T > { :: prisma_client_rust :: QueryRaw :: new (:: prisma_client_rust :: queries :: QueryContext :: new (& self . executor , & self . query_schema) , query , super :: DATABASE_STR) } pub fn _execute_raw (& self , query : :: prisma_client_rust :: raw :: Raw) -> :: prisma_client_rust :: ExecuteRaw { :: prisma_client_rust :: ExecuteRaw :: new (:: prisma_client_rust :: queries :: QueryContext :: new (& self . executor , & self . query_schema) , query , super :: DATABASE_STR) } pub async fn _batch < T : :: prisma_client_rust :: BatchContainer < Marker > , Marker > (& self , queries : T) -> :: prisma_client_rust :: queries :: Result < T :: ReturnType > { :: prisma_client_rust :: batch (queries , & self . executor , & self . query_schema) . await } pub fn user (& self) -> super :: user :: Actions { super :: user :: Actions { client : & self , } } pub fn plugin (& self) -> super :: plugin :: Actions { super :: plugin :: Actions { client : & self , } } pub fn version (& self) -> super :: version :: Actions { super :: version :: Actions { client : & self , } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize)] pub enum PluginScalarFieldEnum { # [serde (rename = "name")] Name , # [serde (rename = "description")] Description , # [serde (rename = "display_name")] DisplayName , # [serde (rename = "author")] Author , # [serde (rename = "publisherId")] PublisherId } impl ToString for PluginScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Name => "name" . to_string () , Self :: Description => "description" . to_string () , Self :: DisplayName => "display_name" . to_string () , Self :: Author => "author" . to_string () , Self :: PublisherId => "publisherId" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize)] pub enum QueryMode { # [serde (rename = "default")] Default , # [serde (rename = "insensitive")] Insensitive } impl ToString for QueryMode { fn to_string (& self) -> String { match self { Self :: Default => "default" . to_string () , Self :: Insensitive => "insensitive" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize)] pub enum SortOrder { # [serde (rename = "asc")] Asc , # [serde (rename = "desc")] Desc } impl ToString for SortOrder { fn to_string (& self) -> String { match self { Self :: Asc => "asc" . to_string () , Self :: Desc => "desc" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize)] pub enum TransactionIsolationLevel { # [serde (rename = "ReadUncommitted")] ReadUncommitted , # [serde (rename = "ReadCommitted")] ReadCommitted , # [serde (rename = "RepeatableRead")] RepeatableRead , # [serde (rename = "Serializable")] Serializable } impl ToString for TransactionIsolationLevel { fn to_string (& self) -> String { match self { Self :: ReadUncommitted => "ReadUncommitted" . to_string () , Self :: ReadCommitted => "ReadCommitted" . to_string () , Self :: RepeatableRead => "RepeatableRead" . to_string () , Self :: Serializable => "Serializable" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize)] pub enum UserScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "name")] Name , # [serde (rename = "username")] Username , # [serde (rename = "avatar_url")] AvatarUrl } impl ToString for UserScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Name => "name" . to_string () , Self :: Username => "username" . to_string () , Self :: AvatarUrl => "avatar_url" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize)] pub enum VersionScalarFieldEnum { # [serde (rename = "version")] Version , # [serde (rename = "pluginName")] PluginName , # [serde (rename = "yanked")] Yanked , # [serde (rename = "digest")] Digest , # [serde (rename = "preview")] Preview } impl ToString for VersionScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Version => "version" . to_string () , Self :: PluginName => "pluginName" . to_string () , Self :: Yanked => "yanked" . to_string () , Self :: Digest => "digest" . to_string () , Self :: Preview => "preview" . to_string () } } } } pub use _prisma :: PrismaClient ;